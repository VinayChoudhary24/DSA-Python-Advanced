## STACK:: Stacks are linear Data structures. the store data in 1-dimensional format.
           ==> Stacks follow LIFO. (Last in First out)

           ==> Insertion Operation in Stacks is called PUSH.
           ==> Removing Operation is Stacks is called POP.

## USE CASES::
             1. In Recursion we have callStack for function calls which is a direct application of it.
             2. Navigatoin Implementation i.e when screens are getting stacked and we try to go back the last screen
                added is removed and so on.
             3. Complex Arithematic Operations.
             4. Features like Undo and Redo.


###Question
Which data structure is used for implementing recursion?

Answer:
Stack, Recursion involves function calls and each function call needs to store:
       1. the return address (where to go back after the function call completes)
       2. local variables of the function
       3. parameters passed to the function
       4. the system uses a call stack to handle this automatically


## Why do we need stacks::
                        1. Stacks put restrictions/limit that when a function call completes it will only call
                           the function added to stack before it. when we want to restict, we can use it.
                        2. to solve complex arithematic ops with parenthesis etc...



## Implementing Stacks using List::
                                 1. Storage
                                 2. Restriction mechanism, list should only use append function to insert and when we
                                    want to access data it should be only from the top of it i.e one side only not both 
                                    and  there should be no random access in between also. 
                                 3. Top Variable, we introduce a Top Variable which always keeps the value of the 
                                    Last Index for access and no one can access any other data than the data in Top
                                    Variable.
                                 4. Peek() Function, introduce a peek function that only gives access to Top Variable.
                                 5. This mechanism of Top variable and Peek Function, Forces LIFO.


# Example to Create Stack, Insert and Implement Restriction Logic

Time and Space Complexity for this is O(1).
class Stack:
    def __init__(self):
        # we use __ to them Private i.e Restriction
        self.__arr = []
        self.__top = None

    # function to insert
    def push(self, data):
        # insert using append
        self.__arr.append(data)

        # update the top variable index for peek func
        self.__top = len(self.__arr) - 1

    # function to access
    def peek(self):
        # check
        if self.__top == None:
            print("Stack is Empty")
            return

        # we only give access to the value of top variable Index
        value = self.__arr[self.__top]
        return value

# Create Stack
st = Stack()

# Insert 
st.push(8)
st.push(10)
st.push(12)
st.push(16)

# access
st.peek()

16


# Example to Create Stack, Remove and Implement Restriction Logic
Time and Space Complexity is O(1)
class Stack:
    def __init__(self):
        # we use __ to them Private i.e Restriction
        self.__arr = []
        self.__top = None

    # function to insert
    def push(self, data):
        # insert using append
        self.__arr.append(data)

        # update the top variable index for peek func
        self.__top = len(self.__arr) - 1

    # function to access
    def peek(self):
        # check
        if self.__top == None:
            print("Stack is Empty")
            return

        # we only give access to the value of top variable Index
        value = self.__arr[self.__top]
        return value

    # function to remove top variable i.e last
    def pop(self):
        if self.__top == None:
            print("Stack is Empty")
            return
            
        self.__arr.pop()

        # update top variable
        self.__top = len(self.__arr) - 1

        # Edge Case
        # when we remove element and that was the last element and now __arr is Empty
        # In this case length will be 0 and 0 - 1 will be -1.
        if self.__top == -1:
            self.__top = None


# Create Stack
st = Stack()

# Insert 
st.push(8)
st.push(10)
st.push(12)
st.push(16)

# remove
st.pop()
st.pop()
st.pop()
st.pop()

# access
st.peek()

Stack is Empty


 
             
###Question
Which of the following operation take  Constant time (O(1)) in the array implementation of stack?

Answer:
Push = O(1), adds at top

Pop = O(1), removes at top

Peek = O(1), access top element

isEmpty and isFull = O(1), simple comparison operations.    



## Implementing Stacks using Linked List::       
                                    1. In LL we Insert at the head and remove from head because it is O(1).
                                    2. In LL head represents the Top Variable.
                                    3. Implement of Stack using LL is better Approach than Stack using Lists/array
                                       because LL has better space complexity and the append operation is O(1) in
                                       most cases but can go to O(n) in worst case. whereas LL adding at head operation
                                       O(1) even in worst cases.


# Example of Implementing Stack using LL

class Stack:
    def __init__(self):
        # Initialize LL
        self.__ll = LinkedList()

    def push(self, data):
        self.__ll.add_at_head(data)

    def pop(self):
        if self.__ll.isEmpty():
            print("Stack is empty")
            return
        self.__ll.remove_at_head()

    def peek(self):
        if self.__ll.isEmpty():
            print("Stack is empty")
            return
        return self.__ll.get_head()

# Create Stack
st = Stack()

# Insert 
st.push(8)
st.push(10)
st.push(12)

# remove
st.pop()

# access
st.peek()

10




###Question
Implement Stack using Singly LL

Implement a Stack Data Structure specifically to store integer data using a Singly Linked List.

The data members should be private.

You need to implement the following public functions :

1. Constructor:
It initialises the data members as required.

2. push(data) :
This function should take one argument of type integer. It pushes the element into the stack and returns nothing.

3. pop() :
It pops the element from the top of the stack and in turn, returns the element being popped or deleted. In case the stack is empty, it returns -1.

4. top :
It returns the element being kept at the top of the stack. In case the stack is empty, it returns -1.

5. size() :
It returns the size of the stack at any given instance of time.

6. isEmpty() :
It returns a boolean value indicating whether the stack is empty or not.

Operations Performed on the Stack:
Query-1(Denoted by an integer 1): Pushes an integer data to the stack.

Query-2(Denoted by an integer 2): Pops the data kept at the top of the stack and returns it to the caller.

Query-3(Denoted by an integer 3): Fetches and returns the data being kept at the top of the stack but doesn't remove it, 
unlike the pop function.

Query-4(Denoted by an integer 4): Returns the current size of the stack.

Query-5(Denoted by an integer 5): Returns a boolean value denoting whether the stack is empty or not.

Answer:
class Node :

    def __init__(self, data) :
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def add_at_head(self, value):
        new_node = Node(value)
        new_node.next = self.head
        self.head = new_node

    def remove_at_head(self):
        if self.head == None:
            return -1
        if self.head.next == None:
            value = self.head.data
            self.head = None
            return value
        
        new_head = self.head.next
        value = self.head.data
        self.head.next = None
        self.head = new_head
        return value

    def isEmpty(self):
        return self.head == None

    def get_head(self):
        if self.isEmpty():
            return
        return self.head.data

class Stack :

    #Define data members and __init__()
    def __init__(self):
        self.__ll = LinkedList()
        self.__size = 0

    def getSize(self) :
        #Implement the getSize() function
        return self.__size

    def isEmpty(self) :
        #Implement the isEmpty() function
        return self.__ll.isEmpty()

    def push(self, data) :
        #Implement the push(element) function
        self.__ll.add_at_head(data)
        self.__size += 1


    def pop(self) :
        #Implement the pop() function
        if self.__ll.isEmpty():
            return -1
        removed = self.__ll.remove_at_head()
        self.__size -= 1
        return removed



    def top(self) :
        #Implement the top() function
        if self.__ll.isEmpty():
            return -1
        return self.__ll.get_head()


s = Stack()
s.push(10)
s.push(20)
s.push(30)

print(s.top())     
print(s.pop())      
print(s.getSize())  
print(s.top())

30
30
2
20



## BALANCED PARENTHESES:: MOST IMP
             ==> A Expression is called balanced if it has Balancing opening and Closing parentheses.

          *****Important properties to remember for problem solving::  
             1. if we have a balanced expression and we wrap that complete expression in a opening and closing
                parentheses than the resulting expression is also balanced. 
                            (a + b) + c ===>> ( (a + b) + c)

             2. if we have 2 balanced parentheses expressions and we concatenate them and the resulting expression is 
                also balanced.
                             (a + b) + c & (c + d) ===>> ( (a + b) + c) (c + d)   
   
                     *****Expected to do::
                      1. we have to find that the given Expression is balanced or not.

                     *****Process::
                             1. we want access of an opening parentheses , JUST BEFORE the closing one to balance it out.

                             2. we use stacks, we only store the opening parentheses in stack for a given expression.
                             3. when we encounter a Closing Parentheses we check for:
                                    i-- do we have a access to a opening parentheses in stack that can balance it out.
                                    ii-- if the stack is empty and we dont have any opening parentheses to balance it,
                                         this means the expression is not balanced and we return False.
                                    iii-- the expression iteration is completed and the stack is not empty i.e there are
                                          some or one opening parentheses in stack. we return False.    


## Example 

def isBalanced(expression):
    if len(expression) == 0:
        return False
    st= []
    # iterate over expression
    for i in range(len(expression)):
        # check and add the opening parentheses in stack
        if expression[i] == "(":
            st.append("(")
        # if closing parentheses
        elif expression[i] == ")":
            # if no parentheses in stack 
            if len(st) == 0:
                return False
            # check in stack if opening parentheses on top
            if st[len(st) - 1] == "(":
                # we found a opening parentheses to balance the closing parentheses
                st.pop()

    # once the loop is over on expression we check if there are still opening parentheses present in stack or not
    return len(st) == 0

isBalanced("((a + b) + a)(c + b)")

True



###Question
Check if the Brackets are balanced

For a given a string expression containing only round brackets or parentheses, check if they are balanced or not. 
Brackets are said to be balanced if the bracket which opens last, closes first.

Answer:
def isBalanced(expression):
    if len(expression) == 0:
        return False
    st= []
    # iterate over expression
    for i in range(len(expression)):
        # check and add the opening parentheses in stack
        if expression[i] == "(":
            st.append("(")
        # if closing parentheses
        elif expression[i] == ")":
            # if no parentheses in stack 
            if len(st) == 0:
                return False
            # check in stack if opening parentheses on top
            if st[len(st) - 1] == "(":
                # we found a opening parentheses to balance the closing parentheses
                st.pop()

    # once the loop is over on expression we check if there are still opening parentheses present in stack or not
    return len(st) == 0

isBalanced("((a + b) + a)(c + b)")

True




## REVERSE A STACK USING A STACK:: 



###Question
Reverse a Stack

You have been given two stacks that can store integers as the data. Out of the two given stacks, one is populated 
and the other one is empty. You are required to write a function that reverses the populated stack using the one 
which is empty.

Answer:


def isStackEmpty(stack):
    return len(stack) == 0

"""
    Reverses a stack using recursion and an auxiliary stack.

    Strategy: For each element, we recursively reverse the remaining stack,
    then insert the current element at the bottom.
"""
def reverseStack(inputStack, extraStack):
    # Base Case: If the stack is empty, nothing to reverse
    if isStackEmpty(inputStack):
        return

    # Step 1: Remove and store the top element
    # This element will be placed at the bottom after reversing the rest    
    top_element = inputStack.pop() # remove the top element and store it

    # Step 2: Recursive call - reverse the remaining stack
    # Recursive Assumption: This will reverse all elements below top_element
    reverseStack(inputStack, extraStack)

    # Step 3: Self Work - Insert top_element at the bottom of the reversed stack
    # To do this, we need to temporarily move all elements out of the way
    # Transfer all elements from inputStack to extraStack
    # This empties inputStack so we can place top_element at the bottom
    while not isStackEmpty(inputStack):
        element = inputStack.pop() # Remove from input
        extraStack.append(element) # Add to extra (temporary storage)

    # Place the original top element at the bottom of inputStack
    inputStack.append(top_element)

    # Move all elements back from extraStack to inputStack
    # This places them on top of top_element, maintaining their reversed order
    while not isStackEmpty(extraStack):
        # transfer remaing elements from extraStack to inputStack
        element = extraStack.pop() # Remove from extra
        inputStack.append(element) # Add back to input

inputStack = [1, 2, 3, 4, 5]  
extraStack = []

print("Original Stack:", inputStack)

reverseStack(inputStack, extraStack)

print("Reversed Stack:", inputStack)

Original Stack: [1, 2, 3, 4, 5]
Reversed Stack: [5, 4, 3, 2, 1]




## NEXT GREATER ELEMENT::

                  Goal: For each element, find the next element to its right that is greater

                  Key Idea: Use a stack to remember indices of elements that haven't found their 
                            "next greater element" yet

                  Direction: Traverse array from left to right (0 to n-1)

 INCREASING Graph Sequence (elements getting larger)
                     1. Easy case - the answer is immediately available!
                     2. When we move from index i to i+1 and arr[i+1] > arr[i]:
                           Element at index i+1 is the next greater element for element at index i
                           We can directly store arr[i+1] at result[i]


 DECRESING Graph Sequence (elements getting Smaller)
                     1. Waiting game - elements must wait for their answer
                     2. When arr[i+1] < arr[i] (next element is smaller):
                          We can't find the answer yet for element at index i
                          We push index i onto the stack to remember it
                          These indices are "waiting" for a greater element

 TRANSITION: Decreasing → Increasing (The Resolution!)
                       now When We Hit an Increasing Point:
                            1. We encounter element which is greater than previous elements
                            2. Now we check the stack - it has indices of elements waiting for an answer
                            3. Pop from stack and resolve all waiting elements:
                                    Pop index and check: is arr[current] > arr[popped_index]?
                                    If YES: result[popped_index] = arr[current] ✓
                                    Continue until stack is empty OR stack top has a larger value and return -1.




###Question
You have been given an array/list ‘ARR’ consisting of ‘N’ positive integers. Your task is to return the Next Greater 
Element(NGE) for every element.

The Next Greater Element for an element ‘X’ is the first element on the right side of ‘X’ in the array 'ARR', 
which is greater than ‘X’. If no such element exists to the right of ‘X’, then return -1.

Answer:
def isStackEmpty(stack):
    return len(stack) == 0

# For each element, find the first element to its right that is greater.
# If no such element exists, return -1.
# Uses a stack-based approach for O(n) time and space complexity.
def next_greater(arr):
    n = len(arr)

    # Initialize output array with -1 (default when no greater element exists)
    output = [-1] * n

    # Stack stores indices of array elements (not the values themselves)
    st = []

    # Push the first index onto the stack
    st.append(0)

    # Iterate through the array starting from index 1
    for i in range(1, n):
        # While stack is not empty AND current element is greater than 
        # the element at the index stored at top of stack
        while not isStackEmpty(st) and arr[i] > arr[st[len(st) - 1]]:
            # Current element (arr[i]) is the next greater element 
            # for the element at index st[top]
            output[st[len(st) - 1]] = arr[i]
            # Remove the index from stack as we found its next greater element
            st.pop()
        # Push current index onto stack to find its next greater element later
        st.append(i)

    # Elements still in stack have no next greater element (remain -1)
    return output

next_greater([1, 3, 5, 8, 3, 4, 7, 10])

[3, 5, 8, 10, 4, 7, 10, -1]



###Question
Find the Previous Greater Number 

Answer:
def previous_greater(arr):
    """
    Find the previous greater element for each element in the array.
    For each element, find the first element to its LEFT that is greater.
    Uses a monotonic decreasing stack, scanning left to right.
    """
    n = len(arr)
    output = [-1] * n
    st = []  # Stack stores indices
    
    # Scan from left to right
    for i in range(n):
        # Pop elements that are smaller than or equal to current element
        while not isStackEmpty(st) and arr[st[len(st) - 1]] <= arr[i]:
            st.pop()
        
        # If stack is not empty, top element is the previous greater
        if not isStackEmpty(st):
            output[i] = arr[st[len(st) - 1]]
        
        # Push current index onto stack
        st.append(i)
    
    return output

previous_greater([1, 3, 5, 8, 3, 4, 7, 10])

[-1, -1, -1, -1, 8, 8, 8, -1]



###Question
Find the next Smaller Number

Asnwer:
def next_smaller(arr):
    """
    Find the next smaller element for each element in the array.
    For each element, find the first element to its RIGHT that is smaller.
    Uses a monotonic increasing stack.
    """
    n = len(arr)
    output = [-1] * n
    st = []  # Stack stores indices
    st.append(0)
    
    for i in range(1, n):
        # Pop elements greater than current element
        while not isStackEmpty(st) and arr[i] < arr[st[len(st) - 1]]:
            output[st[len(st) - 1]] = arr[i]
            st.pop()
        st.append(i)
    
    return output

next_smaller([1, 3, 5, 8, 3, 4, 7, 10])

[-1, -1, 3, 3, -1, -1, -1, -1]



###Question
Find the Previous Smaller number

Answer:
def previous_smaller(arr):
    """
    Find the previous smaller element for each element in the array.
    For each element, find the first element to its LEFT that is smaller.
    Uses a monotonic increasing stack, scanning left to right.
    """
    n = len(arr)
    output = [-1] * n
    st = []  # Stack stores indices
    
    # Scan from left to right
    for i in range(n):
        # Pop elements that are greater than or equal to current element
        while not isStackEmpty(st) and arr[st[len(st) - 1]] >= arr[i]:
            st.pop()
        
        # If stack is not empty, top element is the previous smaller
        if not isStackEmpty(st):
            output[i] = arr[st[len(st) - 1]]
        
        # Push current index onto stack
        st.append(i)
    
    return output

previous_smaller([1, 3, 5, 8, 3, 4, 7, 10])

[-1, 1, 3, 5, 1, 3, 4, 7]



## STOCK SPAN:: MOST IMP
                    1. we have been given a price of stock for n number of days and we need to calculate the stock span.

              Stock Span, span of the stock is the no. of consecutive days before the current day for which price
                          was lesser than current day.

                     *****Stock Span can be calculated using the Previous Greater Number Algo*****




###Question
Stock Span

Amit has been working with an organization called 'Money Traders' for the past few years. The organization is into 
the money trading business. His manager assigned him a task. For a given array/list of stock's prices for N days, 
find the stock's span for each day.

The span of the stock's price today is defined as the maximum number of consecutive days(starting from today and 
going backwards) for which the price of the stock was less than today's price.

Explanation:
For the stock prices [100, 80, 60, 70, 60, 75, 85], the span of each day is calculated by counting consecutive 
previous days with a price less than or equal to today's price:

Day 1 (100): No previous days, span = 1.
Day 2 (80): Less than 100, span = 1.
Day 3 (60): Less than 80, span = 1.
Day 4 (70): Greater than 60, span = 2.
Day 5 (60): Less than 70, span = 1.
Day 6 (75): Greater than 60, 70, and 60, span = 4.
Day 7 (85): Greater than all previous days, span = 6.
Final spans: [1, 1, 1, 2, 1, 4, 6].        
             
Answer Using Next Greater Element:

def isStackEmpty(stack):
    return len(stack) == 0

def next_greater_idx(arr):
    """
    This function returns the index of the next greater element for each element in the array.
    If no greater element exists, the value remains -1.
    """
    n = len(arr)

    # Initialize output with -1 for all elements (default when next greater does NOT exist)
    output = [-1] * n

    # Stack stores indices of array elements (not the values themselves)
    st = []

    # Push the first index onto the stack
    st.append(0)

    # Iterate through the array starting from index 1
    for i in range(1, n):
        # While stack is NOT empty and current value is greater/equal to the value at stack top
        # arr[i] is the next greater element for arr[st[-1]]
        while not isStackEmpty(st) and arr[i] >= arr[st[len(st) - 1]]:
            output[st[len(st) - 1]] = i # store next greater index
            # Remove the index from stack as we found its next greater element
            st.pop()
        # Push current index onto stack to find its next greater element later
        st.append(i)

    # Elements still in stack have no next greater element (remain -1)
    return output

def stock_span(price):
    # Reverse because NGE gives next greater on right,
    # but span logic requires next greater on LEFT.
    price.reverse()

    # Get next greater element (index)
    nge = next_greater_idx(price)

    # Convert NGE index into span values
    for i in range(len(nge)):
        if nge[i] == -1:
            # No greater element → span equals remaining length
            nge[i] = len(nge) - i
        else:
            # Distance between current index and next greater index
            nge[i] = nge[i] - i

     # Reverse again to match original order
    nge.reverse()
    return nge

stock_span([100, 80, 70, 60, 30, 40, 60, 80, 110])

[1, 1, 1, 1, 1, 2, 3, 6, 9]


Answer Using Previous Greater Element:

def isStackEmpty(stack):
    return len(stack) == 0

def previous_greater_index(arr):
    """
    Find the INDEX of previous greater element for each element in the array.
    For each element, find the first element to its LEFT that is greater.
    Returns indices instead of values.
    """
    n = len(arr)
    output = [-1] * n  # Stores indices, -1 means no previous greater exists
    st = []  # Stack stores indices
    
    # Scan from left to right
    for i in range(n):
        # Pop elements that are smaller than or equal to current element
        while not isStackEmpty(st) and arr[st[len(st) - 1]] < arr[i]:
            st.pop()
        
        # If stack is not empty, store the INDEX of previous greater element
        if not isStackEmpty(st):
            output[i] = st[len(st) - 1]  # Store index, not value
        
        # Push current index onto stack
        st.append(i)
    
    return output

"""
    Calculate stock span for each day.
    Stock span = number of consecutive days before current day 
    where price was less than or equal to current day's price.
    
    Formula: 
    - If no previous greater exists: span = current_index + 1 (all days from start)
    - If previous greater exists: span = current_index - previous_greater_index
    """
def stock_span(price):
    n = len(price)
    pge_indices = previous_greater_index(price)  # Get indices of previous greater elements
    span = [0] * n

    for i in range(n):
        if pge_indices[i] == -1:
            # No previous greater element, span includes all days from start to current
            span[i] = i + 1
        else:
            # Span is the distance from previous greater element to current
            span[i] = i - pge_indices[i]
    
    return span

stock_span([100, 80, 70, 60, 30, 40, 60, 80, 110])

[1, 1, 1, 1, 1, 2, 3, 6, 9]




## TRAPPING RAINWATER::
                    1. we need to calculate the amount of water trapped between buildings
                    2. to calculate the amount for (i)th building, we can calculate the previous greater and the
                       next greater building.
                    3. we can maintain two arrays:
                                       ==> TL(Left to Right), represents the previous buildings
                                       ==> TR(Right to Left), represents the Next buildings 
                    
                    4. now we calculate:
                                 Summation of (Height of current Building - min(tl - tr)) * 1 




###Question
Trapping Rainwater

You have been given a long type array/list 'arr’ of size 'n’.

It represents an elevation map wherein 'arr[i]’ denotes the elevation of the 'ith' bar.

Print the total amount of rainwater that can be trapped in these elevations.

Note :
The width of each bar is the same and is equal to 1.

Answer:

"""
    Calculate the total amount of rainwater that can be trapped between bars.
    
    Key Concept:
    Water trapped at any position = min(leftMax, rightMax) - height[i]
    - leftMax: Maximum height to the LEFT of current position (including current)
    - rightMax: Maximum height to the RIGHT of current position (including current)
    - The water level is determined by the minimum of these two (like a container)
    
    Time Complexity: O(n)
    Space Complexity: O(n)
    """
def getTrappedWater_op(arr, n):
    if n == 0:
        return 0

    # Result
    totalWaterStored = 0

    # Arrays to store maximum height to the left and right of each position
    leftMax = [0] * n  # leftMax[i] = maximum height from index 0 to i
    rightMax = [0] * n # rightMax[i] = maximum height from index i to n-1

    leftMax[0] = arr[0]


     # Fill leftMax array from left to right
    # leftMax[i] = maximum of all elements from index 0 to i
    for i in range(1, n):
        # Current leftMax is either the previous leftMax or current height (whichever is greater)
        leftMax[i] = max(leftMax[i - 1], arr[i])

    # Initialize: The rightMax at last position is the height itself
    rightMax[n - 1] = arr[n - 1]

    # Fill rightMax array from right to left
    # rightMax[i] = maximum of all elements from index i to n-1
    for i in range(n-2, -1, -1):
        # Current rightMax is either the next rightMax or current height (whichever is greater)
        rightMax[i] = max(arr[i], rightMax[i + 1])

    # Calculate the total water trapped
    # Skip first and last positions as they are boundaries and cannot trap water
    for i in range(1, n - 1):
        # Water at position i = minimum of (leftMax, rightMax) - current height
        # min(leftMax, rightMax) gives the water level at position i
        # Subtract arr[i] to get the actual water trapped (excluding the bar itself)
        totalWaterStored += min(rightMax[i], leftMax[i]) - arr[i]

    return totalWaterStored

print(getTrappedWater_op([0,1,0,2,1,0,1,3,2,1,2,1], 12))

6




## INTRODUCTION TO MATHEMATICAL EXPRESSION::
                    1. Infix Notation => when the Operator is placed between the Operands. (5 + 3)
 
                    2. Prefix Notation(Polish Nota.) = > when the operator is placed before the Operands. (+ 5 3).
                                      -- we dont need parentheses.

                    3. Postfix Notation(Reverse Polish Nota.) => when the Operator is placed after the operands. (5 3 +)
                                     -- we dont need parentheses.





## Convert prefix into Infix
                >>Prefix Expression: * - 5 / 2 3 - / 5 2 6

                          1. Scan the prefix expression from RIGHT to LEFT (this is critical!)
                          2. Use a stack to store intermediate infix expressions (as strings)
                          3. When you encounter:

                                             --Operand (number): Push it to stack as a string
                                             --Operator: Pop two operands, create infix expression, push back


### Step-by-Step Execution:
Step 1: See 6 (operand)

Action: Push "6"
Stack: ["6"]

Step 2: See 2 (operand)

Action: Push "2"
Stack: ["6", "2"]

Step 3: See 5 (operand)

Action: Push "5"
Stack: ["6", "2", "5"]

Step 4: See / (operator)

Action:

Pop1 = "5" (first operand)
Pop2 = "2" (second operand)
Create: "(" + "5" + "/" + "2" + ")" = "(5/2)"
Push "(5/2)"


Stack: ["6", "(5/2)"]

Step 5: See - (operator)

Action:

Pop1 = "(5/2)" (first operand)
Pop2 = "6" (second operand)
Create: "(" + "(5/2)" + "-" + "6" + ")" = "((5/2)-6)"
Push "((5/2)-6)"


Stack: ["((5/2)-6)"]

Step 6: See 3 (operand)

Action: Push "3"
Stack: ["((5/2)-6)", "3"]

Step 7: See 2 (operand)

Action: Push "2"
Stack: ["((5/2)-6)", "3", "2"]

Step 8: See / (operator)

Action:

Pop1 = "2" (first operand)
Pop2 = "3" (second operand)
Create: "(" + "2" + "/" + "3" + ")" = "(2/3)"
Push "(2/3)"


Stack: ["((5/2)-6)", "(2/3)"]

Step 9: See 5 (operand)

Action: Push "5"
Stack: ["((5/2)-6)", "(2/3)", "5"]

Step 10: See - (operator)

Action:

Pop1 = "5" (first operand)
Pop2 = "(2/3)" (second operand)
Create: "(" + "5" + "-" + "(2/3)" + ")" = "(5-(2/3))"
Push "(5-(2/3))"


Stack: ["((5/2)-6)", "(5-(2/3))"]

Step 11: See * (operator)

Action:

Pop1 = "(5-(2/3))" (first operand)
Pop2 = "((5/2)-6)" (second operand)
Create: "(" + "(5-(2/3))" + "*" + "((5/2)-6)" + ")" = "((5-(2/3))*((5/2)-6))"
Push "((5-(2/3))*((5/2)-6))"


Stack: ["((5-(2/3))*((5/2)-6))"]

Final Result: "((5-(2/3))*((5/2)-6))"
                                                               


###Question
Prefix to infix

You are given a string denoting a valid Prefix expression containing ‘+’, ’-’, ’*’, ‘/’ and lowercase letters.

Convert the given Prefix expression into an Infix expression.

Note:
Infix notation is a method of writing mathematical expressions in which operators are placed between operands. 
For example, "a + b" represents the addition of a and b.

Prefix notation is a method of writing mathematical expressions in which operators are placed before the operands. 
For example, "+ a b" represents the addition of a and b.

Answer:

def isOperator(char):
    return char == "+" or char == "-" or char == "*" or char == "/" or char == "%"

def prefix_to_infix(s):
    """
    Algorithm:
    1. Scan the prefix expression from RIGHT to LEFT
    2. Use a stack to store intermediate infix expressions (as strings)
    3. For operands: push to stack
    4. For operators: pop two operands, create infix, push back
    """

    if len(s) == 0:
        return
    # Time Complexity: O(n) and sometime O(n^2) where n is length of prefix expression
    # Space Complexity: O(n) for the stack
    i = len(s) - 1
    st = []

    # Scan the prefix expression from right to left
    while i >= 0:
        if isOperator(s[i]):
            expr1 = st.pop() # Pop first operand (this will be the LEFT operand in infix)
            expr2 = st.pop() # Pop second operand (this will be the RIGHT operand in infix)
            # Push the newly created infix expression back onto stack
            st.append("(" + expr1 + s[i] + expr2 + ")") # Add parentheses to maintain correct operator precedence
        else:
            # Current character is a number (operand)
            # Simply push it to the stack as a string
            st.append(s[i])

        # Move to the next character (moving left in the string)
        i = i - 1

    # After processing all characters, stack should have exactly ONE element
    # This element is the complete infix expression
    result = st.pop()
    return result

prefix_to_infix("*-5/23-/526")

'((5-(2/3))*((5/2)-6))'



###Question
Postfix to Prefix

You are given a string denoting a valid Postfix expression containing ‘+’, ’-’, ’*’, ‘/’ and lowercase letters.

Convert the given Postfix expression into a Prefix expression.

Note:
Postfix notation is a method of writing mathematical expressions in which operators are placed after the operands. 
For example, "a b +" represents the addition of a and b.

Prefix notation is a method of writing mathematical expressions in which operators are placed before the operands. 
For example, "+ a b" represents the addition of a and b.

Expression contains lowercase English letters, ‘+’, ‘-’, ‘*’, and  ‘/’.

Answer:

def isOperator(char):
    return char == "+" or char == "-" or char == "*" or char == "/" or char == "%"

def postfix_to_prefix(s):
    """
    Convert a postfix expression to prefix expression.
    
    Algorithm:
    1. Scan the postfix expression from LEFT to RIGHT
    2. Use a stack to store intermediate prefix expressions (as strings)
    3. For operands: push to stack
    4. For operators: pop two operands, create prefix, push back
    
    Key Difference from Postfix to Infix:
    - In postfix to infix: we create (operand1 operator operand2)
    - In postfix to prefix: we create operator operand1 operand2
    
    Time Complexity: O(n) and sometime O(n^2) where n is length of postfix expression
    Space Complexity: O(n) for the stack
    """
    
    if len(s) == 0:
        return

    # Initialize index to scan from LEFT to RIGHT
    i = 0
    
    # Stack to store intermediate prefix expressions as strings
    # Each element in stack is a string representing a partial prefix expression
    st = []
    
    # Scan the postfix expression from left to right
    while i < len(s):
        
        # Check if current character is an operator (+, -, *, /)
        if isOperator(s[i]):
            # OPERATOR CASE:
            operand2 = st.pop() # Pop first operand (this will be the SECOND operand in prefix)
            operand1 = st.pop() # Pop second operand (this will be the FIRST operand in prefix)
            
            # Create PREFIX expression: operator operand1 operand2
            # Format: operator + operand1 + operand2
            # No parentheses needed in prefix notation
            prefix_expr = s[i] + operand1 + operand2
            
            # Push the newly created prefix expression back onto stack
            st.append(prefix_expr)
        
        else:
            # OPERAND CASE:
            # Current character is a number (operand)
            # Simply push it to the stack as a string
            st.append(s[i])
        
        # Move to the next character (moving left to right in the string)
        i = i + 1
    
    # After processing all characters, stack should have exactly ONE element
    # This element is the complete prefix expression
    result = st.pop()
    
    return result

print(postfix_to_prefix("523/5-*526/-*"))

**5-/235-5/26




###Question
Check Redundant Brackets

For a given expression in the form of a string, find if there exist any redundant brackets or not. It is given that 
the expression contains only rounded brackets or parenthesis and the input expression will always be balanced.

A pair of the bracket is said to be redundant when a sub-expression is surrounded by unnecessary or needless brackets.

Example:
Expression: (a+b)+c
Since there are no needless brackets, hence, the output must be 'false'.

Expression: ((a+b))
The expression can be reduced to (a+b). Hence the expression has redundant brackets and the output will be 'true'.
Note:
You will not get a partial score for this problem. You will get marks only if all the test cases are passed.
Return "false" if no brackets are present in the input.

Answer:

def find(ch):
    if ch == "+" or ch == "-" or ch == "*" or ch == "/" or ch == "%":
        return True
    return False

def isEmpty(stack):
     return len(stack) == 0

def top(stack):
    return stack[len(stack) - 1]

"""
    Check if there are redundant (unnecessary) brackets in the expression.
    
    Key Strategy:
    - Push only opening brackets '(' and operators onto stack
    - Ignore operands (like 'a', 'b', etc.) - don't push them
    - When closing bracket ')' is found:
      * Pop until we reach '('
      * If we popped anything, brackets are valid (hasOperator = True)
      * If we popped nothing, brackets are redundant (hasOperator = False)
    
    Why ignore operands?
    - We only care if there's SOMETHING (operator or operand) between brackets
    - Since we're popping until '(', if stack.pop() happens even once, 
      it means there was something between the brackets
    - The hasOperator flag tracks whether we popped anything, not just operators
    
    Time Complexity: O(n) where n is length of expression
    Space Complexity: O(n) for the stack
    """
def checkRedundantBrackets(expression):
    
    # Stack to store opening brackets '(' and operators
    stk = []
    for i in range(len(expression)):
        # Case 1: Opening bracket '(' OR Operator (+, -, *, /, %)
        if (expression[i] == "(") or (find(expression[i])):
            # Push opening brackets and operators onto stack
            # We DON'T push operands (like 'a', 'b', '1', '2', etc.)
            stk.append(expression[i])
        # Case 2: Closing bracket ')'
        elif expression[i] == ")":
            # Flag to track if we found anything between '(' and ')'
            # This will be True if we pop ANY element (operator OR nothing)
            # Naming note: 'hasOperator' is slightly misleading - 
            # it really means "has something between brackets"
            hasOperator = False
            # Pop all elements until we find the matching opening bracket '('
            while not isEmpty(stk) and top(stk) != "(":
                # Pop an element from stack
                stk.pop()

                # Since we popped something, there was content between brackets
                # Set flag to True (brackets contain something, so NOT redundant)
                hasOperator = True
            # After the while loop:
            # - If hasOperator = False: we didn't pop anything
            #   This means ')' immediately followed '(' with nothing in between
            #   Example: "()" or after removing operands: effectively "()"
            #   These brackets are REDUNDANT
            if not hasOperator:
                # No operator/content found between '(' and ')'
                # Brackets are redundant
                return True
            # If hasOperator = True: we popped at least one element
            # This means there was an operator between '(' and ')'
            # These brackets are VALID (not redundant)

            # Now remove the matching opening bracket '(' from stack
            if not isEmpty(stk):
                # Remove the '('
                stk.pop()
    # If we've processed the entire expression without finding redundant brackets
    return False

checkRedundantBrackets("((a+b))")

True



###Question
Minimum Bracket Reversal

For a given expression in the form of a string, find the minimum number of brackets that can be reversed in order 
to make the expression balanced. The expression will only contain curly brackets.

If the expression can't be balanced, return -1.

Example:
Expression: {{{{
If we reverse the second and the fourth opening brackets, the whole expression will get balanced. Since we have 
to reverse two brackets to make the expression balanced, the expected output will be 2.

Expression: {{{
In this example, even if we reverse the last opening bracket, we would be left with the first opening bracket and 
hence will not be able to make the expression balanced and the output will be -1.

Answer:

def isEmpty(stack):
     return len(stack) == 0

def top(stack):
    return stack[len(stack) - 1]

"""
    Find the minimum number of bracket reversals needed to balance the expression.
    
    Algorithm:
    1. Handle edge cases (empty string, odd length)
    2. Remove all balanced pairs using stack (similar to bracket matching)
    3. After removal, remaining brackets follow pattern: }}}...{{{ 
       (closing brackets at bottom, opening brackets at top)
    4. Process remaining brackets in pairs from stack:
       - If pair is DIFFERENT (like '}{' or '{}'): need 2 reversals
       - If pair is SAME (like '}}' or '{{'): need 1 reversal
    
    Why this works:
    - '}' and '{' together (different): reverse both → 2 reversals
    - '}}' together (same): reverse first '}' to get '{}' → 1 reversal
    - '{{' together (same): reverse second '{' to get '{}' → 1 reversal
    
    Time Complexity: O(n)
    Space Complexity: O(n)
"""
def countBracketReversals(inputString):
    length = len(inputString)

    # Edge case 1: Empty string is already balanced
    if length == 0:
        return 0

    # Edge case 2: If length is odd, it's impossible to balance
    # We need pairs of brackets, so even length is required
    if length % 2 != 0:
        return -1

    # Stack to store unbalanced brackets
    # Will be used to remove all balanced pairs first
    stack = []

    # Step 1: Remove all balanced pairs
    # Iterate through each character in the input string
    for i in range(length):
        currentChar = inputString[i]
        # Case 1: Opening bracket '{'
        if currentChar == "{":
            # Always push opening bracket to stack
            stack.append(currentChar)
        # Case 2: Closing bracket '}'
        else:
            # Check if we can form a balanced pair
            # Condition: stack is not empty AND top element is opening bracket '{'
            if (not isEmpty(stack)) and (top(stack) == "{"):
                # We found a matching pair: '{' and '}'
                # Remove the balanced pair by popping the opening bracket
                stack.pop()
            else:
                # No matching opening bracket found
                # This closing bracket is unbalanced, so push it to stack
                stack.append(currentChar)
                
    # After the loop, stack contains only UNBALANCED brackets
    # Pattern in stack (from bottom to top): }}}...{{{
    # All closing brackets '}' are at the bottom
    # All opening brackets '{' are at the top

    # Step 2: Count minimum reversals needed
    # Process remaining unbalanced brackets in pairs
    count = 0
    # Process brackets in pairs from top of stack
    while not isEmpty(stack):
        # Pop two brackets from stack
        # char1 is popped first (was higher in stack)
        # char2 is popped second (was lower in stack)
        char1 = stack.pop()
        char2 = stack.pop()

        # Check if the pair is different or same
        if char1 != char2:
            # Case 1: Different brackets (e.g., '}' and '{' or '{' and '}')
            # Pattern like "}{" or "{}"
            # To balance "}{": need to reverse BOTH brackets
            #   - Reverse '}' to '{' 
            #   - Reverse '{' to '}'
            # Result: Need 2 reversals
            count += 2
        else:
            # Case 2: Same brackets (e.g., '}}' or '{{')
            # Pattern like "}}" or "{{"
            # To balance "}}": reverse first '}' to get "{}"
            #   - Result: "{}" (balanced with 1 reversal)
            # To balance "{{": reverse second '{' to get "{}"
            #   - Result: "{}" (balanced with 1 reversal)
            # Result: Need 1 reversal
            count += 1

    # Return the total number of reversals needed
    return count

countBracketReversals("{{}}{{")

1



###Question
You are given an array 'ARR' of integers of length N. Your task is to find the next smaller element for each of 
the array elements.

Next Smaller Element for an array element is the first element to the right of that element which has a value 
strictly smaller than that element.

If for any array element the next smaller element does not exist, you should print -1 for that array element.

For Example:
If the given array is [ 2, 3, 1], we need to return [1, 1, -1]. Because for  2, 1 is the Next Smaller element. 
For 3, 1 is the Next Smaller element and for 1, there is no next smaller element hence the answer for this element 
is -1.

Answer:

def isStackEmpty(stack):
     return len(stack) == 0

def next_smaller(arr):
    """
    Find the next smaller element for each element in the array.
    For each element, find the first element to its RIGHT that is smaller.
    Uses a monotonic increasing stack.
    """
    n = len(arr)
    output = [-1] * n
    st = []  # Stack stores indices
    st.append(0)
    
    for i in range(1, n):
        # Pop elements greater than current element
        while not isStackEmpty(st) and arr[i] < arr[st[len(st) - 1]]:
            output[st[len(st) - 1]] = arr[i]
            st.pop()
        st.append(i)
    
    return output

next_smaller([1, 3, 5, 8, 3, 4, 7, 10])

[-1, -1, 3, 3, -1, -1, -1, -1]




###Question
Postfix to Infix

You are given a mathematical expression in postfix notation. The expression consists of alphabets(both lowercase 
and uppercase) and operators.

Convert this expression to infix notation.

Note:
Surround every expression with a pair of parentheses “()”.

Example:
Input: ‘postfix’ = “ab+c+”
Output: ‘infix’ = “((a+b)+c)”

Explanation: The expression ((a+b)+c)” in infix is equivalent to “ab+c+” in postfix.

Answer:

def isOperator(char):
    return char == "+" or char == "-" or char == "*" or char == "/" or char == "%"

def postfix_to_infix(s):
    """
    Convert postfix expression to fully parenthesized infix expression.

    Algorithm:
    1. Scan from LEFT → RIGHT
    2. If operand → push to stack
    3. If operator:
         - pop operand2
         - pop operand1
         - newExpr = "(" + operand1 + operator + operand2 + ")"
         - push newExpr

    Note:
    - Surround EVERY expression with parentheses as required.
    """

    # Handle empty string edge case
    if len(s) == 0:
        return

    # Stack to store operands and intermediate infix expressions
    st = []
    i = 0

    # Scan the postfix expression from left to right
    while i < len(s):
        # CASE 1: Current character is an operator
        if isOperator(s[i]):   # OPERATOR CASE
            operand2 = st.pop() # Pop the right operand (top of stack)
            operand1 = st.pop() # Pop the left operand (next element in stack)

            # Create fully parenthesized infix expression
            # Format: (left_operand operator right_operand)
            expr = "(" + operand1 + s[i] + operand2 + ")"
            st.append(expr) # Push the newly formed infix expression back onto the stack
        # CASE 2: Current character is an operand (alphabet/number)
        else:                  
            # OPERAND CASE
            # Push the operand directly onto the stack
            st.append(s[i])    # push letter (alphabet)

        # Move to the next character
        i += 1

    # The final element in the stack is the complete infix expression
    return st.pop()

print(postfix_to_infix("ABC*+D/"))

((A+(B*C))/D)