## QUEUES:: When we want to Implement FIFO, First In First Out.
            1. No Existing Data Structure Directly Inforce FIFO. so we need Queues.
            2. Queues directly supports FIFO.
            3. Queues are Linear Data Structures.

     ==> Insertion is from the back of the Queue. insert operation is called enqueue i.e enqueue(Element)
     ==> Removing is from the front of the Queue. remove operation is called dequeue i.e dequeue()
     ==> getFront(), is used to access the front element of the Queue.
     ==> Just like stacks in queue we cannot access any other elements than the Top/front Element.

## Use in Python
   from queue import Queue
   # the queue constructor in python gives us 2 methods, GET and PUT
   # get --> front() + dequeue()
   # put --> enqueue()
   # .empty() --> checks if queue is empty or not
   


## USE CASES/ APPLICATIONS::

               1. CPU Scheduling, which process to be executed next. 
               2. Any Scheduling logic needs Queues
               3. Printer Queues
               4. Mail Queues


## IMPLEMENTATION USING LISTS::
                     1. Storage 
	             
                     2. Restriction Mechanism for FIFO.
                     
                     3. For Enqueue we use Lists Append function. which is constant O(1) Ops.
                    
                     4. Last Index is the BACK of Queue and Zero Index is the FRONT of Queue.
        
                     5. For Dequeue we use Lists Pop Function with index 0th i.e pop(0). which is O(n)

                     6. getFront Value, we use arr[0]. which is O(1)		


# Example for Implementing Queues using Lists

class Queue:
    def __init__(self):
        self.__arr = []

    def isEmpty(self):
        return len(self.__arr) == 0

    def enqueue(self, data):
        # Adds the data to the back
        self.__arr.append(data)

    def dequeue(self):
        if self.isEmpty():
            print("Queue is Empty")
            return

        # Removes the data from the front
        self.__arr.pop(0)

    def getFront(self):
        if self.isEmpty():
            print("Queue is Empty")
            return

        # Access the Element from the front
        value = self.__arr[0]
        return value

qu = Queue()

qu.enqueue(5)
qu.enqueue(10)
qu.enqueue(15)

qu.dequeue()
qu.dequeue()

qu.getFront()

15



###Question
Implement Queues using Arrays

Queue is a linear data structure that follows the idea of First In First Out. That means insertion and retrieval 
operations happen at opposite ends.

Implement a simple queue using arrays.

You are given 'query' queries which are either of the 2 types:

1 'e': Enqueue (add) element ‘e’ at the end of the queue.

2: Dequeue (retrieve) the element from the front of the queue. If the queue is empty, return -1.

Answer:

class Queue:
    def __init__(self):
        self.front = 0 # Points to the first element in the queue
        self.rear = 0 # Points to the next available position for insertion
        self.arr= [0] * 100001 # Pre-allocated array with maximum capacity
    
    #  Enqueue (add) element 'e' at the end of the queue.
    def enqueue(self, e: int) -> None:
        self.arr[self.rear] = e # Place element at the rear position
        self.rear += 1 # Move rear pointer forward

    #  Dequeue (retrieve) the element from the front of the queue.
    def dequeue(self) -> int:
        if self.front == self.rear:
            return -1

        val = self.arr[self.front]
        self.front += 1 # Move front pointer forward (remove element logically)
        return val

qu2 = Queue()

qu2.enqueue(5)
qu2.enqueue(10)
qu2.enqueue(15)

qu2.dequeue()
qu2.dequeue()

10



## IMPLEMENTING USING LINKED LISTS::
                      1. the Head becomes front of the Queue
                      2. the Tail becomes back of the Queue

                      3. In LL we also maintain the tailnode for better Time Complexity.
                                 self.head = None
                                 self.tail = None
                      4. we maintain head and tail for Queue Class because of this all the Ops are O(1), Queues
                         Using LL is Better Approach than Lists/Arrays.



## Example to Implement Queues using LL
Implement Queues using LL

You are given ‘q’ queries, where each query can be of the following types:

(1) 1 x -> this means to push the element ‘x’ in the queue.
(2) 2 -> This means deleting the front element of the queue and returning it. If there’s no element in the queue, 
return -1.
Your task is to implement a queue that supports these two queries.

You must write an algorithm whose time complexity is O(1), and whose space complexity is O(1).

Note:
In the output, you will see the output of queries of type 2. 
In the queries, there will be at least one type 2 query.
You will be given two functions, ‘push’, and ‘pop’. 
Your task is to implement the two functions.

Answer:

class Node:
    def __init__(self, value):
        self.data = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None
        self.tail = None

    def isEmpty(self):
        return self.head == None

    def add_to_tail(self, value):
        new_node = Node(value)

        # if the LL is Empty
        if self.isEmpty():
            self.head= new_node
            # update the tail
            self.tail = new_node
            return

            # insert at the tail  
        self.tail.next = new_node
        # update the tail
        self.tail = new_node

    def remove_at_head(self):
        if self.isEmpty():
            print("Queue is empty")
            return

        # if there is only one Node
        if self.head.next == None:
            # data = self.head.data
            self.head = None
            # update the tail
            self.tail = None
            return

        # remove at the head
        new_head = self.head.next
        self.head.next = None
        # update the head
        self.head = new_head
        # data = self.head.data
        # return data
        
    def get_front(self):
        if self.isEmpty():
            print("Queue is empty")
            return

        # return the head value
        value = self.head.data
        return value


class Queue:
    def __init__(self):
        self.__ll = LinkedList()

    def enqueue(self, value):
        self.__ll.add_to_tail(value)

    def dequeue(self):
        self.__ll.remove_at_head()

    def get_head(self):
        return self.__ll.get_front()

# Create Queue
qu3 = Queue()

# Insert 
qu3.enqueue(8)
qu3.enqueue(10)
qu3.enqueue(12)

# remove
# qu3.dequeue()
qu3.dequeue()
qu3.dequeue()

# access
qu3.get_head()

12



###Question
In optimized linked list implementation of a queue, where does a new element be inserted?

Answer:

At the Tail of the LL



###Qusetion
In linked list implementation of queue, if only front pointer is maintained, which of the following operation 
take worst case time (i.e. O(n) )?

Answer:
Insert from Tail/Rear



## IMPLEMENTATION USING TWO STACKS:: MOST IMP

                         1. Stacks directly does not follow FIFO.
                         2. we need to make changes in the dequeue Operation:
                               -- Empty primary stack into Secondary Stack.
                               -- Pop the Top-Most element of secondary Stack.
                               -- Bring all elements back to primary stack.


## Example to Implement Queues using Two stacks(ENQUEUE EFFICIENT)
         ***When Insertion Operations are more than Removing

class Stack_Queue:
    def __init__(self):
        self.__st = []

    # check if stack is Empty
    def isEmpty(self):
        return len(self.__st) == 0

    def enqueue(self, value):
        # O(1)
        self.__st.append(value)

    def dequeue(self):
        # O(n)
        if self.isEmpty():
            print("Queue is empty")
            return
        
        # secondary Stack
        secondary = []

        # move all elements from primary to secondary stack
        while not (len(self.__st) == 0):
            top_element = self.__st[len(self.__st) - 1]
            secondary.append(top_element)
            self.__st.pop()

        # check if secondary has element
        if len(secondary) != 0:
            secondary.pop()

        # bring back the remaining elements from secondary to primary st
        while not (len(secondary) == 0):
            top_ele = secondary[len(secondary) - 1]
            self.__st.append(top_ele)
            secondary.pop()

    def front(self):
        # O(n)
        if self.isEmpty():
            print("Queue is empty")
            return
        # secondary Stack
        secondary = []

        # move all elements from primary to secondary stack
        while not (len(self.__st) == 0):
            top_element = self.__st[len(self.__st) - 1]
            secondary.append(top_element)
            self.__st.pop()

        result = None
        # check if secondary has element
        if len(secondary) != 0:
            # store the top ele from secondary for queue
            result = secondary[len(secondary) - 1]

        # bring back the remaining elements from secondary to primary st
        while not (len(secondary) == 0):
            top_ele = secondary[len(secondary) - 1]
            self.__st.append(top_ele)
            secondary.pop()

        return result

# Create Queue
qu5 = Stack_Queue()

# Insert 
qu5.enqueue(8)
qu5.enqueue(10)
qu5.enqueue(12)

# remove
qu5.dequeue()
qu5.dequeue()

# Access
qu5.front()

12



###Question
Queues Using Two Stacks-- ENQUEUE EFIICIENT

You will be given ‘Q’ queries. You need to implement a queue using two stacks according to those queries. 
Each query will belong to one of these three types:

1 ‘X’: Enqueue element ‘X’  into the end of the nth queue. Returns true after the element is enqueued.

2: Dequeue the element at the front of the nth queue. Returns -1 if the queue is empty, otherwise, returns 
the dequeued element.
Note:
Enqueue means adding an element to the end of the queue, while Dequeue means removing the element from the 
front of the queue.

Answer ENQUEUE EFFICIENT:

class Queue_Stack:
    # Stacks to be used in the operations.
    def __init__(self):
        self.stk1 = []
        self.stk2 = []

    """
    Strategy:
    - stk1: Used for enqueue operations (input stack)
    - stk2: Used for dequeue operations (output stack)
    - When dequeuing, if stk2 is empty, transfer all elements from stk1 to stk2
      (this reverses the order, making the oldest element accessible at the top)
    """
    def enqueue(self, X):
        self.stk1.append(X) # Push element to input stack
        return True

    """
    Process:
        1. Check if both stacks are empty → return -1
        2. If stk2 is empty, transfer all elements from stk1 to stk2
           (This reverses the order: oldest element becomes top of stk2)
        3. Pop and return the top element from stk2
        
        Time Complexity: 
        - Amortized O(1): Each element is moved at most once from stk1 to stk2
        - Worst case O(n): When stk2 is empty and we need to transfer n elements
    """
    def dequeue(self):
        # Check if queue is empty (both stacks are empty)
        if not self.stk1 and not self.stk2:
            return -1
        # If output stack (stk2) is empty, transfer elements from input stack (stk1)
        if not self.stk2:
            # Move all elements from stk1 to stk2 (this reverses the order)
            while self.stk1:
                self.stk2.append(self.stk1.pop())
        # Pop the front element from stk2 (top of stk2 is the oldest element)
        return self.stk2.pop()

    def front(self):
        if not self.stk1 and not self.stk2:
            return -1

        # If output stack (stk2) is empty, transfer elements from input stack (stk1)
        if not self.stk2:
            # Move all elements from stk1 to stk2
            while self.stk1:
                self.stk2.append(self.stk1.pop())

        # Return the top element of stk2 without removing it
        # stk2[-1] gives the last element (top of stack)
        return self.stk2[-1]


# Create Queue
qu6 = Queue_Stack()

# Insert 
qu6.enqueue(8)
qu6.enqueue(10)
qu6.enqueue(12)

# remove
qu6.dequeue()
# qu6.dequeue()

# Access
qu6.front()

12

Answer DEQUEUE EFFICIENT:

class Queue_Stack_DequeueEff:
    def __init__(self):
        self.stk1 = []  # This stack always has front at top
        self.stk2 = []  # Temporary stack used during enqueue

    # Enqueue: O(n)
    def enqueue(self, x):
        # Move everything from stk1 to stk2
        while self.stk1:
            self.stk2.append(self.stk1.pop())

        # Push new element to stk1
        self.stk1.append(x)

        # Move everything back to stk1 so front stays on top
        while self.stk2:
            self.stk1.append(self.stk2.pop())

        return True

    # Dequeue: O(1)
    def dequeue(self):
        if not self.stk1:
            return -1
        return self.stk1.pop()   # top is always the front

    # Front: O(1)
    def front(self):
        if not self.stk1:
            return -1
        return self.stk1[-1]     # top element is the front

# Create Queue
qu8 = Queue_Stack_DequeueEff()

# Insert 
qu8.enqueue(8)
qu8.enqueue(10)
qu8.enqueue(12)

# remove
qu8.dequeue()
qu8.dequeue()

# Access
qu8.front()

12




## Example to Implement Queues using Two stacks(DEQUEUE EFFICIENT)
              ***To implement dequeue efficient, we need to modify insertion in stack so that first element is always
                 on top and so on.


class Stack_Queue_Deeueu:
    def __init__(self):
        self.__st = []

    def isEmpty(self):
        return len(self.__st) == 0

    def enqueue(self, value):
        sec = []

        while not (len(self.__st) == 0):
            top_element = self.__st[len(self.__st) - 1]
            self.__st.pop()
            sec.append(top_element)

        self.__st.append(value)

        while not (len(sec) == 0):
            top_ele = sec[len(sec) - 1]
            sec.pop()
            self.__st.append(top_ele)

    def dequeue(self):
        if self.isEmpty():
            print("Queue is empty")
            return

        self.__st.pop()

    def front(self):
        if self.isEmpty():
            print("Queue is empty")
            return

        return self.__st[len(self.__st) - 1]


# Create Queue
qu7 = Stack_Queue_Deeueu()

# Insert 
qu7.enqueue(8)
qu7.enqueue(10)
qu7.enqueue(12)

# remove
qu7.dequeue()
qu7.dequeue()

# Access
qu7.front()

12



###Question
Insert at the Bottom of the Stack and Remove the element at the top and also access the top element of the stack.

Answer:
class Queue_Stack_DequeueEff:
    def __init__(self):
        self.stk1 = []  # This stack always has front at top
        self.stk2 = []  # Temporary stack used during enqueue

    # Enqueue: O(n)
    def enqueue(self, x):
        # Move everything from stk1 to stk2
        while self.stk1:
            self.stk2.append(self.stk1.pop())

        # Push new element to stk1
        self.stk1.append(x)

        # Move everything back to stk1 so front stays on top
        while self.stk2:
            self.stk1.append(self.stk2.pop())

        return True

    # Dequeue: O(1)
    def dequeue(self):
        if not self.stk1:
            return -1
        return self.stk1.pop()   # top is always the front

    # Front: O(1)
    def front(self):
        if not self.stk1:
            return -1
        return self.stk1[-1]     # top element is the front

# Create Queue
qu8 = Queue_Stack_DequeueEff()

# Insert 
qu8.enqueue(8)
qu8.enqueue(10)
qu8.enqueue(12)

# remove
qu8.dequeue()
qu8.dequeue()

# Access
qu8.front()

12



###Question
Queue Using Stack

Implement a queue data structure which follows FIFO(First In First Out) property, using only the instances of the 
stack data structure.

Note:
1. To implement means you need to complete some predefined functions, which are supported by a normal queue such 
that it can efficiently handle the given input queries which are defined below.

2. The implemented queue must support the following operations of a normal queue: 

a. enQueue(data) : This function should take one argument of type integer and place the integer to the back of the queue.

b. deQueue(): This function should remove an integer from the front of the queue and also return that integer. 
If the queue is empty, it should return -1.

c. peek(): This function returns the element present in the front of the queue. If the queue is empty, it should return -1.

d. isEmpty(): This function should return true if the queue is empty and false otherwise.

3. You will be given q queries of 4 types:

a. 1 val - For this type of query, you need to insert the integer val to the back of the queue.

b. 2 - For this type of query, you need to remove the element from the front of the queue, and also return it.

c. 3 - For this type of query, you need to return the element present at the front of the queue(No need to remove it from the queue).

d. 4 - For this type of query, you need to return true if the queue is empty and false otherwise.

4. For every query of type:

a. 1, you do not need to return anything.

b. 2, return the integer being deQueued from the queue.

c. 3, return the integer present in the front of the queue.

d. 4, return “true” if the queue is empty, “false” otherwise.
 

Answer:

class Queue_Stack_DequeueEff:
    def __init__(self):
        self.stk1 = []  # This stack always has front at top
        self.stk2 = []  # Temporary stack used during enqueue

    # Enqueue: O(n)
    def enqueue(self, x):
        # Move everything from stk1 to stk2
        while self.stk1:
            self.stk2.append(self.stk1.pop())

        # Push new element to stk1
        self.stk1.append(x)

        # Move everything back to stk1 so front stays on top
        while self.stk2:
            self.stk1.append(self.stk2.pop())

        return True

    # Dequeue: O(1)
    def dequeue(self):
        if not self.stk1:
            return -1
        removed_ele = self.stk1[len(self.stk1) - 1]
        self.stk1.pop()
        return removed_ele

    # Front: O(1)
    def front(self):
        if not self.stk1:
            return -1
        return self.stk1[-1]     # top element is the front

# Create Queue
qu8 = Queue_Stack_DequeueEff()

# Insert 
qu8.enqueue(8)
qu8.enqueue(10)
qu8.enqueue(12)

# remove
qu8.dequeue()
qu8.dequeue()

# Access
qu8.front()

12




## IMPLEMENTATION OF STACKS USING QUEUES::
                   1. The Approach is derived from Queues Using Stacks


# Example 

class Node_Stack_Queue:
    def __init__(self, value):
        self.data = value  # storing the incoming value passed by user in the data property
        self.next = None

class LinkedList_Stack_Queue:
    def __init__(self):
        self.head = None  # points to the first element of the list
        self.tail = None  # points to the last element of the list

    def add_at_tail(self, data):
        new_node = Node_Stack_Queue(data)  # create a new node

        if self.head is None:
            # If the list is empty, both head and tail point to the new node
            self.head = new_node
            self.tail = new_node
        else:
            # If the list is not empty, add the new node to the tail
            self.tail.next = new_node  # Connect the current tail to the new node
            self.tail = new_node  # Update tail to point to the new node

    def remove_from_head(self):
        if self.head is None:
            return -1  # If the list is empty, nothing to remove
        if self.head.next is None:
            # If the list has only one element, set both head and tail to None
            data = self.head.data
            self.head = None
            self.tail = None
            return data

        # If the list has more than one element, remove the head and return its data
        data = self.head.data
        self.head = self.head.next
        return data

    def is_empty(self):
        return self.head is None  # Returns True if the list is empty, else False

    def get_head(self):
        if self.is_empty():
            return -1
        return self.head.data  # Return the data of the head node


class Stack_Using_Queue:
    def __init__(self):
        self.__ll = LinkedList_Stack_Queue()

    def enqueue(self, data):
        return self.__ll.add_at_tail(data)

    def is_empty(self):
        return self.__ll.is_empty()

    def dequeue(self):
        if self.is_empty():
            return -1
        
        return self.__ll.remove_from_head()

    def get_front(self):
        return self.__ll.get_head()


"""
Strategy:
    - Push: Simply enqueue to the main queue (O(1))
    - Pop/Top: Use a temporary queue to move all elements except the last one,
      then access/remove the last element (O(n))
"""

class Stack_Use_Queue:
    def __init__(self):
        self.__qu = Stack_Using_Queue() # Main queue to store stack elements

    def push(self, value):
        self.__qu.enqueue(value)

    def pop(self):
        """
        Process:
        1. Check if queue is empty → return -1
        2. Create a temporary queue (sec_qu)
        3. Move all elements EXCEPT the last one from main queue to temporary queue
        4. The last element in main queue is the top of stack - remove it
        5. Move all elements back from temporary queue to main queue
        """
        if self.__qu.is_empty():
            print("Stack is empty")
            return -1
        # Create a temporary queue to hold elements temporarily
        sec_qu = Stack_Using_Queue()
        last_removed = None
        # Transfer all elements except the last one to temporary queue
        while not self.__qu.is_empty():
            # Get the front element from main queue
            last_removed = self.__qu.get_front()
            self.__qu.dequeue() # Remove it from main queue
             # If main queue is now empty, we've reached the last element
            # This last element is the top of the stack - don't add it to sec_qu
            if self.__qu.is_empty():
                break # last_removed holds the top of stack, exit loop
            # Add this element to temporary queue (it's not the last one)
            sec_qu.enqueue(last_removed)

        # Restore all elements from temporary queue back to main queue
        while not sec_qu.is_empty():
            self.__qu.enqueue(sec_qu.get_front())
            sec_qu.dequeue()

        return last_removed

    """
    Process:
        1. Check if queue is empty → return -1
        2. Create a temporary queue (sec_qu)
        3. Move ALL elements from main queue to temporary queue
           (keeping track of the last element)
        4. The last element moved is the top of stack
        5. Move all elements back from temporary queue to main queue
        6. Return the top element
    """
    def top(self):
        if self.__qu.is_empty():
            print("Stack is empty")
            return -1
        
        sec_qu = Stack_Using_Queue()

        last_removed = None
        # Transfer ALL elements to temporary queue
        while not self.__qu.is_empty():
            last_removed = self.__qu.get_front()
            self.__qu.dequeue()
            sec_qu.enqueue(last_removed)

        # Store the top of stack (last element we moved)
        top_of_stack = last_removed

        while not sec_qu.is_empty():
            self.__qu.enqueue(sec_qu.get_front())
            sec_qu.dequeue()

        # Return the top element (without removing it from stack)
        return top_of_stack

# create Stack
s = Stack_Use_Queue()

# push
s.push(8)
s.push(10)
s.push(12)

# pop
s.pop()
s.pop()

# access
s.top()

8



###Question
Stack Using Queues

Implement a Stack Data Structure specifically to store integer data using two Queues.

There should be two data members, both being Queues to store the data internally. You may use the inbuilt Queue.

Implement the following public functions :

1. Constructor:
It initializes the data members(queues) as required.

2. push(data) :
This function should take one argument of type integer. It pushes the element into the stack and returns nothing.

3. pop() :
It pops the element from the top of the stack and, in turn, returns the element being popped or deleted. 
In case the stack is empty, it returns -1.

4. top :
It returns the element being kept at the top of the stack. In case the stack is empty, it returns -1.

5. size() :
It returns the size of the stack at any given instance of time.

6. isEmpty() :
It returns a boolean value indicating whether the stack is empty or not.

Operations Performed on the Stack:
Query-1(Denoted by an integer 1): Pushes an integer data to the stack. (push function)

Query-2(Denoted by an integer 2): Pops the data kept at the top of the stack and returns it to the caller. (pop function)

Query-3(Denoted by an integer 3): Fetches and returns the data being kept at the top of the stack but doesn't remove it, 
unlike the pop function. (top function)

Query-4(Denoted by an integer 4): Returns the current size of the stack. (size function)

Query-5(Denoted by an integer 5): Returns a boolean value denoting whether the stack is empty or not. (isEmpty function) 

Answer:

from typing import List

class Node_Stack_Queue:
    def __init__(self, value):
        self.data = value  # storing the incoming value passed by user in the data property
        self.next = None

class LinkedList_Stack_Queue:
    def __init__(self):
        self.head = None  # points to the first element of the list
        self.tail = None  # points to the last element of the list
        self.size = 0

    def add_at_tail(self, data):
        new_node = Node_Stack_Queue(data)  # create a new node

        if self.head is None:
            # If the list is empty, both head and tail point to the new node
            self.head = new_node
            self.tail = new_node
        else:
            # If the list is not empty, add the new node to the tail
            self.tail.next = new_node  # Connect the current tail to the new node
            self.tail = new_node  # Update tail to point to the new node

        self.size += 1

    def remove_from_head(self):
        if self.head is None:
            return -1  # If the list is empty, nothing to remove
        if self.head.next is None:
            # If the list has only one element, set both head and tail to None
            data = self.head.data
            self.head = None
            self.tail = None
            self.size -= 1
            return data

        # If the list has more than one element, remove the head and return its data
        data = self.head.data
        self.head = self.head.next
        self.size -= 1
        return data

    def is_empty(self):
        return self.head is None  # Returns True if the list is empty, else False

    def get_size(self):
        return self.size

    def get_head(self):
        if self.is_empty():
            return -1
        return self.head.data  # Return the data of the head node


class Stack_Using_Queue:
    def __init__(self):
        self.__ll = LinkedList_Stack_Queue()

    def enqueue(self, data):
        return self.__ll.add_at_tail(data)

    def getSize(self):
        return self.__ll.get_size()

    def is_empty(self):
        return self.__ll.is_empty()

    def dequeue(self):
        if self.is_empty():
            return -1
        
        return self.__ll.remove_from_head()

    def get_front(self):
        return self.__ll.get_head()


class Stack:
    def __init__(self):
        self.__qu = Stack_Using_Queue() # Main queue to store stack elements

    def isEmpty(self):
        return self.__qu.is_empty()

    def getSize(self):
        return self.__qu.getSize()

    def push(self, value):
        self.__qu.enqueue(value)

    def pop(self):
       
        if self.__qu.is_empty():
            return -1
        # Create a temporary queue to hold elements temporarily
        sec_qu = Stack_Using_Queue()
        last_removed = None
        # Transfer all elements except the last one to temporary queue
        while not self.__qu.is_empty():
            # Get the front element from main queue
            last_removed = self.__qu.get_front()
            self.__qu.dequeue() # Remove it from main queue
             # If main queue is now empty, we've reached the last element
            # This last element is the top of the stack - don't add it to sec_qu
            if self.__qu.is_empty():
                break # last_removed holds the top of stack, exit loop
            # Add this element to temporary queue (it's not the last one)
            sec_qu.enqueue(last_removed)

        # Restore all elements from temporary queue back to main queue
        while not sec_qu.is_empty():
            self.__qu.enqueue(sec_qu.get_front())
            sec_qu.dequeue()

        return last_removed

   
    def top(self):
        if self.__qu.is_empty():
            return -1
        
        sec_qu = Stack_Using_Queue()

        last_removed = None
        # Transfer ALL elements to temporary queue
        while not self.__qu.is_empty():
            last_removed = self.__qu.get_front()
            self.__qu.dequeue()
            sec_qu.enqueue(last_removed)

        # Store the top of stack (last element we moved)
        top_of_stack = last_removed

        while not sec_qu.is_empty():
            self.__qu.enqueue(sec_qu.get_front())
            sec_qu.dequeue()

        # Return the top element (without removing it from stack)
        return top_of_stack


# create Stack
s1 = Stack()

# push
s1.push(8)
s1.push(10)
s1.push(12)

# pop
s1.pop()
s1.pop()

# access
s1.top()
s1.getSize()

8
1




## REVERSE A QUEUE::
           1. To reverse a Queue we need to store queue elements in a data structure which makes sure we get 
              reverse order. 
           2. Queue follows FIFO so we use Stack which follows LIFO. 
           3. we remove each element from Queue and store it in Stack and when we remove from Stack(LIFO) and 
              Insert Back in Queue, the Queue is Reversed.


           ## Use in Python
              from queue import Queue
              # the queue constructor in python gives us 2 methods, GET and PUT
              # get --> front() + dequeue()
              # put --> enqueue()
              # .empty() --> checks if queue is empty or not


###Question
Reverse a Queue Using Stack

Answer:

from queue import Queue

# Create a new Queue object (from Python's queue module)
qu = Queue()

# Add elements to the queue using put() method
# Queue follows FIFO (First In First Out) principle
qu.put(10)  # Queue: [10]
qu.put(20)  # Queue: [10, 20]
qu.put(30)  # Queue: [10, 20, 30]
qu.put(40)  # Queue: [10, 20, 30, 40]
qu.put(50)  # Queue: [10, 20, 30, 40, 50]


"""
Algorithm:
    1. Dequeue all elements from the queue and push them onto a stack
    2. Pop all elements from the stack and enqueue them back to the queue
    
    Key Insight:
    - Queue is FIFO (First In First Out) → [20, 30, 40, 50]
    - Stack is LIFO (Last In First Out)  → reverses order
    - By using stack as intermediate storage, we reverse the queue

    Time Complexity: O(n) where n is the number of elements
    Space Complexity: O(n) for the temporary stack
"""
def reverse_queue(qu):
    # Step 1: Create an empty stack (using Python list)
    # Stack will temporarily hold all queue elements in reverse order
    stack = []
    # Step 2: Transfer all elements from queue to stack
    # This empties the queue and fills the stack
    while not qu.empty():
         # Remove element from front of queue (FIFO)
        # Push element onto top of stack (LIFO)
        stack.append(qu.get())

    # Step 3: Transfer all elements from stack back to queue
    # This fills the queue with elements in reversed order
    while not (len(stack) == 0):
        # Get the element at the top of stack (last position in list)
        qu.put(stack[len(stack) - 1])
        # Remove element from top of stack
        stack.pop()

reverse_queue(qu)

qu.get()

50



###Question
Reverse Queue itself

You have been given a queue that can store integers as the data. You are required to write a function that 
reverses the populated queue itself without using any other data structures.

Answer:

from queue import Queue

# Create a new Queue object (from Python's queue module)
qu = Queue()

# Add elements to the queue using put() method
# Queue follows FIFO (First In First Out) principle
qu.put(10)  # Queue: [10]
qu.put(20)  # Queue: [10, 20]
qu.put(30)  # Queue: [10, 20, 30]
qu.put(40)  # Queue: [10, 20, 30, 40]
qu.put(50)  # Queue: [10, 20, 30, 40, 50]


def reverse_queue_itself(qu):
    """
    Reverse a queue without using any extra data structure.
    Uses recursion - the call stack implicitly stores elements.
    
    Algorithm:
    1. Base case: If queue is empty, return
    2. Recursive case:
       - Dequeue the front element
       - Recursively reverse the remaining queue
       - Enqueue the dequeued element at the rear
    
    Key Insight:
    - Recursion uses the call stack to temporarily hold elements
    - As recursion unwinds, elements are added back in reverse order
    
    Args:
        qu: Queue object to be reversed (modified in-place)
    
    Time Complexity: O(n) where n is the number of elements
    Space Complexity: O(n) for recursion call stack
    
    Example:
        Input:  [10, 20, 30, 40, 50] (10 at front)
        Output: [50, 40, 30, 20, 10] (50 at front)
    """
    
    # Base case: If queue is empty, we're done
    if qu.empty():
        return
    
    # Step 1: Remove the front element from queue
    front_element = qu.get()
    
    # Step 2: Recursively reverse the remaining queue
    reverse_queue(qu)
    
    # Step 3: Add the removed element to the rear (after recursion unwinds)
    # This places it at the end, effectively reversing the order
    qu.put(front_element)

reverse_queue_itself(qu)

qu.get()

50




## REVERSE THE FIRST K ELEMENTS::
           ==> we can reverse the First Kth elements Using Stack Approach:
                          1. move first kth elements in the stack 
                          2. bring back the kth elements from stack to queue
                          3. remove n - k elements from queue and add them again to the queue i.e now these remaining
                             n- k elements from front will be on back of the queue
                             


###Question
Reverse Kth elements in Queue Using Stack

Answer:

from queue import Queue

# Create a new Queue object (from Python's queue module)
qu = Queue()

# Add elements to the queue using put() method
# Queue follows FIFO (First In First Out) principle
qu.put(10)  # Queue: [10]
qu.put(20)  # Queue: [10, 20]
qu.put(30)  # Queue: [10, 20, 30]
qu.put(40)  # Queue: [10, 20, 30, 40]
qu.put(50)  # Queue: [10, 20, 30, 40, 50]
qu.put(60)  # Queue: [10, 20, 30, 40, 50, 60]


"""
Algorithm:
    1. Validate parameters (k must be valid)
    2. Dequeue first K elements and push them onto a stack
    3. Pop all elements from stack and enqueue them back (this reverses first K)
    4. Dequeue and enqueue the remaining (n-k) elements to move them to the end

    Time Complexity: O(n + k) where n is the queue size, k is the stack
    Space Complexity: O(k) for the stack
"""
def reverse_kth_elements(qu, k):
    # Check if k is invalid:
    # - k <= 0: Cannot reverse zero or negative elements
    # - k > qu.qsize(): Cannot reverse more elements than exist
    # - qu.empty(): Cannot reverse elements in an empty queue
    if k <= 0 or k > qu.qsize() or qu.empty():
        print("Invalid Params")
        return qu

    # Create a stack to temporarily hold the first K elements
    # Stack will reverse the order (LIFO property)
    stack = []

    # Remove the first K elements from queue and push to stack
    for i in range(k):
        stack.append(qu.get())

    # Transfer all elements from stack back to queue
    # This reverses their order (due to LIFO property of stack)
    while not (len(stack) == 0):
        # Get the element at the top of stack (last position in list)
        qu.put(stack[len(stack) - 1])
        # Remove element from top of stack
        stack.pop()

    # The reversed elements are now at the end of queue
    # We need to move the remaining (n-k) elements to the rear
    # This will bring the reversed elements to the front
    for i in range(qu.qsize() - k):
        # Dequeue and enqueue the remaining elements
    # This effectively rotates them to the rear
        qu.put(qu.get())

    # Return the modified queue
    return qu

reverse_kth_elements(qu, 4)
# [40, 30, 20, 10, 50, 60]
qu.get()

40



###Question
Reverse the kth elements in the Queue itself

For a given queue containing all integer data, reverse the first K elements.

You have been required to make the desired change in the input queue itself.

Answer:

from queue import Queue

# Create a new Queue object (from Python's queue module)
qu1 = Queue()

# Add elements to the queue using put() method
# Queue follows FIFO (First In First Out) principle
qu1.put(10)  # Queue: [10]
qu1.put(20)  # Queue: [10, 20]
qu1.put(30)  # Queue: [10, 20, 30]
qu1.put(40)  # Queue: [10, 20, 30, 40]
qu1.put(50)  # Queue: [10, 20, 30, 40, 50]
qu1.put(60)  # Queue: [10, 20, 30, 40, 50, 60]


def reverse_k_recursive(q, k):
    # Base Case: Stop when we have processed k elements
    if k == 0:
        return q
    
    # 1. DEQUEUE: Remove the front element
    # This element is stored in the current function's "stack frame"
    front = q.get()
    
    # 2. RECURSE: Process the next element
    # This pauses execution here and goes deeper into the stack 
    reverse_k_recursive(q, k - 1)
    
    # 3. ENQUEUE: Add the element back to the REAR
    # This line executes only after the recursive calls return (Unwinding phase).
    # Because the stack unwinds in Last-In-First-Out order, 
    # the last element removed (k-th) is added back first.
    q.put(front)


def reverseKElements(inputQueue, k) :
    n = inputQueue.qsize()
    # Edge case handling
    if k <= 0 or k > n:
        return inputQueue

    # --- PHASE 1: Reverse First K Elements ---
    # We use the recursion stack to reverse the first k items.
    # Note: After this runs, the reversed items are at the BACK of the queue.
    # Queue becomes: [50, 60, 40, 30, 20, 10]
    reverse_k_recursive(inputQueue, k)

    # --- PHASE 2: Rotate Remaining Elements ---
    # The elements that were NOT reversed (50, 60) are currently at the front.
    # We need to move them to the back to maintain their original relative order.
    # We move (n - k) elements.
    for _ in range(n - k):
        # Remove from front and immediately add to back
        inputQueue.put(inputQueue.get())

    # Final State: [40, 30, 20, 10, 50, 60]
    return inputQueue

reverseKElements(qu1, 4)
# [40, 30, 20, 10, 50, 60]
qu1.get()

40



#####################################################################################################
###################################### DOUBLE ENDED QUEUES ###########################################
#######################################################################################################
    1. Efficiently Iserts/Removes elements from both Ends i.e Front and Back of the Queue.
    
    2. we can us LL, we can keep track of our head and tail and utilize for Queues:
             -- LL-Head to remove and insert at the head of Queues
             -- LL-Tail to remove and insert at the tail of Queues


    3. Just like queues python has inbuilt double ended queues
               -- from collections import deque


# Example to Insert and Remove in deque

from collections import deque

d = deque()

# Insert from the Back
d.append(10)
d.append(20)
d.append(30)

# Insert from the Front
d.appendleft(40)
d.appendleft(50)
d.appendleft(60)

# Remove from front
d.popleft() # 60
d.popleft() # 50

# Remove from Back
d.pop() # 30




###Question
Deque

You need to implement a class for Dequeue i.e. for double ended queue. In this queue, elements can be inserted 
and deleted from both the ends.

You don't need to double the capacity.

You need to implement the following functions -

1. constructor
You need to create the appropriate constructor. Size for the queue passed is 10.

2. insertFront -
This function takes an element as input and insert the element at the front of queue. Insert the element only if queue is not full. And if queue is full, print -1 and return.

3. insertRear -
This function takes an element as input and insert the element at the end of queue. Insert the element only if queue is not full. And if queue is full, print -1 and return.

4. deleteFront -
This function removes an element from the front of queue. Print -1 if queue is empty.

5. deleteRear -
This function removes an element from the end of queue. Print -1 if queue is empty.

6. getFront -
Returns the element which is at front of the queue. Return -1 if queue is empty.

7. getRear -
Returns the element which is at end of the queue. Return -1 if queue is empty.

Answer:

class Deque:
    def __init__(self):
        self.size = 10
        self.arr = [0] * self.size
        self.front = -1
        self.rear = -1

    def isEmpty(self):
        return self.front == -1

    def isFull(self):
        return (self.rear + 1) % self.size == self.front

    def insertFront(self, value):
        if self.isFull():
            # print(-1)
            return False

        if self.isEmpty():
            self.front = self.rear = 0
        else:
            self.front = (self.front - 1 + self.size) % self.size

        self.arr[self.front] = value
        return True

    def insertRear(self, value):
        if self.isFull():
            # print(-1)
            return False

        if self.isEmpty():
            self.front = self.rear = 0
        else:
            self.rear = (self.rear + 1) % self.size

        self.arr[self.rear] = value
        return True

    
    def deleteFront(self):
        if self.isEmpty():
            # print(-1)
            return False

        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.front = (self.front + 1) % self.size
        return True

        
    def deleteRear(self):
        if self.isEmpty():
            # print(-1)
            return False

        if self.front == self.rear:
            self.front = self.rear = -1
        else:
            self.rear = (self.rear - 1 + self.size) % self.size
        return True
        
    def getFront(self):
        if self.isEmpty():
            return -1
        
        return self.arr[self.front]

    def getRear(self):
        if self.isEmpty():
            return -1

        return self.arr[self.rear]


dq = Deque()

dq.insertFront(10)
dq.insertFront(20)
dq.insertRear(30)
dq.insertRear(40)

dq.deleteFront()
# dq.deleteFront()
# dq.deleteFront()
dq.deleteRear()

print(dq.getFront())
print(dq.getRear())

10
30                    							